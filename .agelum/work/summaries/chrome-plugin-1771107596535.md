# Summary: Chrome Plugin Enhancement – Phase 1

**Date**: 2026-02-14
**Plan**: `.agelum/work/plans/chrome-plugin-1771106302323.md`
**Phase**: 1 – Authentication & User Registry (Site App)

---

## What Was Implemented

### 1. Dependency Updates (`apps/site/package.json`)

Added the following production dependencies:
- `next-auth@^5.0.0-beta.25` – Auth.js v5 for OAuth
- `@auth/drizzle-adapter@^1.7.4` – NextAuth Drizzle ORM adapter
- `drizzle-orm@^0.38.0` – Drizzle ORM
- `postgres@^3.4.5` – PostgreSQL client (postgres.js, recommended by Drizzle)
- `ioredis@^5.4.1` – Redis client

Added dev dependency:
- `drizzle-kit@^0.30.0` – CLI for migrations

Added npm scripts: `db:generate`, `db:migrate`, `db:push`, `db:studio`

---

### 2. Database Schema (`apps/site/src/lib/db/schema.ts`)

Drizzle ORM schema with PostgreSQL tables:

| Table | Purpose |
|---|---|
| `users` | OAuth user profiles (NextAuth compatible) |
| `accounts` | OAuth provider account links (NextAuth) |
| `sessions` | Database sessions (NextAuth) |
| `verification_tokens` | Email verification (NextAuth) |
| `inbox_tasks` | Tasks created by the Chrome plugin |

`inbox_tasks` columns: `id` (uuid pk), `repo`, `title`, `description`, `screenshot_data_url`, `source_url`, `reporter`, `priority`, `state` (default: "inbox"), `synced_at`, `created_at`.

---

### 3. DB Connection (`apps/site/src/lib/db/index.ts`)

- Uses `drizzle-orm/postgres-js` with `postgres.js` client
- Singleton pattern via `globalThis` to prevent connection leaks during Next.js hot reload
- Throws early if `DATABASE_URL` is not set

---

### 4. Redis Client (`apps/site/src/lib/redis.ts`)

- `ioredis` singleton with `globalThis` hot-reload guard
- `cacheGet`, `cacheSet`, `cacheDel` helper functions
- TTL constants: `USER` = 5 min, `INBOX` = 1 min
- Cache errors are non-fatal (best-effort)

---

### 5. Drizzle Config (`apps/site/drizzle.config.ts`)

- Schema path: `./src/lib/db/schema.ts`
- Migrations output: `./src/lib/db/migrations`
- Dialect: `postgresql`, reads `DATABASE_URL` env var

---

### 6. NextAuth OAuth (`apps/site/src/auth.ts` + route)

- **Providers**: GitHub, Google, Yandex (custom OAuth2 provider pointing to `oauth.yandex.com`)
- **Adapter**: `DrizzleAdapter` wired to the Drizzle `db` instance and all four NextAuth tables
- **Session strategy**: `"database"` (no JWTs)
- **Callbacks**: `session` callback injects `user.id` into the session object
- **Pages**: custom sign-in at `/auth/signin`, error at `/auth/error`

Route handler at `apps/site/src/app/api/auth/[...nextauth]/route.ts` re-exports `{ GET, POST }` from `@/auth`.

**Required env vars** (to be configured by developer):
```
AUTH_SECRET=
AUTH_GITHUB_ID=
AUTH_GITHUB_SECRET=
AUTH_GOOGLE_ID=
AUTH_GOOGLE_SECRET=
AUTH_YANDEX_ID=
AUTH_YANDEX_SECRET=
DATABASE_URL=
REDIS_URL=
```

---

### 7. User Registry API

#### `POST /api/v1/users/register`
- Upserts a user record in postgres on first OAuth login (or profile update)
- Invalidates and refreshes Redis cache on change
- Returns `{ id, email, name, image }` — HTTP 201 on create, 200 on update
- No auth required (called server-side after OAuth callback)

#### `GET /api/v1/users/verify?email=<email>`
- Checks if an email exists in the `users` table
- Returns `{ authorized: true, user: { id, email, name } }` or `{ authorized: false }`
- Uses Redis cache (TTL 5 min) to reduce DB load
- No auth required (called by the Chrome plugin / web app)

---

### 8. Inbox API (`apps/site/src/app/api/v1/inbox/route.ts`)

New endpoint for the **electron app** to poll for tasks created by the Chrome plugin.

#### `GET /api/v1/inbox?repo=<repo>[&since=<ISO>&synced=false|true|all]`
- Requires Bearer API key auth (same key file mechanism)
- Returns unsynced tasks for a repo by default (`synced=false`)
- Supports `since` ISO timestamp filter for incremental polling
- Results cached in Redis for 1 minute

#### `PATCH /api/v1/inbox?id=<uuid>`
- Requires Bearer API key auth
- Marks a task's `synced_at` timestamp → electron has processed it
- Invalidates the inbox cache for that repo

---

### 9. Updated Reports Route (`apps/site/src/app/api/v1/reports/route.ts`)

The existing `/api/v1/reports` POST handler now:
1. **Inserts** the task into `inbox_tasks` in postgres (authoritative store)
2. Invalidates the inbox Redis cache for the repo
3. **Also tries** to write the local markdown file (best-effort, non-fatal if it fails)
4. Returns `{ id: <db-uuid>, success: true, path?, fileId? }`

This dual-write ensures the electron app can always read new tasks via the API even if the local file write fails (e.g., running in a Docker container without the project mounted).

---

## Data Flow After Phase 1

```
Chrome Plugin
  └─► POST /api/v1/reports (Bearer API key)
       ├─► inbox_tasks row inserted in postgres
       ├─► Redis inbox cache invalidated
       └─► Local .md file written (best-effort)

Electron App (polling)
  └─► GET /api/v1/inbox?repo=X (Bearer API key)
       ├─► Redis cache hit → fast response
       └─► DB query for unsynced tasks
  └─► PATCH /api/v1/inbox?id=<uuid>
       └─► syncedAt timestamp set; electron creates local .md file

OAuth Users (plugin users)
  └─► OAuth flow → /api/auth/[...nextauth]
       └─► POST /api/v1/users/register (auto-called)
  └─► Plugin verifies user → GET /api/v1/users/verify?email=X
```

---

## Phases Not Yet Implemented

- **Phase 2**: Auth gateway in Web app + settings login/logout UI (depends on Phase 1 OAuth)
- Sign-in page UI at `/auth/signin` (placeholder; real UI is a future task)
- Electron-side polling code (would be in `apps/electron` or `apps/web`)
