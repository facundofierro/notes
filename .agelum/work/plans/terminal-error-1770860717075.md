---
created: 2026-02-11T23:45:00.000Z
task: .agelum/work/tasks/fixes/terminal-error.md
type: plan
---

# Plan: Fix Terminal Stream Controller Error & Re-join Interaction

## Problem Summary

Two related bugs in the terminal/agent streaming architecture:

1. **Server crash**: When a user navigates away from a page with a running terminal session, the `ReadableStream` controller is closed by the client disconnect, but `child.stdout.on("data")` listeners continue firing and call `controller.enqueue()` on the closed controller, causing `TypeError: Invalid state: Controller is already closed`.

2. **No interaction after re-join**: When re-connecting to a running session via `GET /api/terminal?id=X`, the user can see output but cannot type. The input path (`POST /api/agents/input`) technically works (process stdin is still writable), but the client-side wiring has gaps that prevent reliable bidirectional communication after reconnection.

## Root Cause Analysis

### Bug 1: Controller Already Closed

**Location**: `apps/web/src/app/api/(agents)/agents/route.ts:172` and `:182`

The `ReadableStream` is created with `child.stdout.on("data")` and `child.stderr.on("data")` listeners that call `controller.enqueue(data)`. When the client disconnects (navigates away), the stream controller is closed. However:

- There is **no `request.signal` abort listener** to remove the stdout/stderr listeners.
- There is **no try-catch** around `controller.enqueue()` calls.
- The `child.on("close")` and `child.on("error")` handlers also call `controller.enqueue()` and `controller.close()` without checking state.

The same issue exists in `apps/web/src/app/api/(system)/terminal/route.ts:140` and `:149` (POST handler), and in the GET handler's polling loop at line `:62`.

### Bug 2: No Input After Re-join

**Location**: `apps/web/src/components/layout/AIRightSidebar.tsx:213-278`

When `reconnectToSession()` runs:
- It correctly sets `terminalProcessId` state (line ~220).
- `handleTerminalInput` (line 423) depends on `terminalProcessId` being set and sends `POST /api/agents/input`.
- The server-side input route (`agents/input/route.ts`) correctly writes to `process.stdin`.

The actual problem is that `reconnectToSession` sets `isTerminalRunning` to `true` during the stream, but the `handleTerminalInput` callback may not have the updated `terminalProcessId` due to React closure staling, or the TerminalViewer's `onInput` prop may not be wired correctly after reconnection. Need to verify exact wiring during implementation.

---

## Phase 1: Fix the Server-Side Controller Crash

This phase addresses the critical `TypeError: Invalid state: Controller is already closed` error.

### 1.1 Add safe-enqueue helper and abort handling in `agents/route.ts`

**File**: `apps/web/src/app/api/(agents)/agents/route.ts`

Inside the `ReadableStream` `start(controller)` callback (line 122), add:

1. A `let controllerClosed = false` flag at the top of the `start` function.
2. A helper function `safeEnqueue(chunk)` that checks `controllerClosed` before calling `controller.enqueue()`, wrapped in try-catch.
3. A helper function `safeClose()` that checks `controllerClosed`, sets it to `true`, and calls `controller.close()`.
4. An `request.signal.addEventListener("abort", ...)` listener that:
   - Sets `controllerClosed = true`.
   - Removes `child.stdout` and `child.stderr` "data" listeners (store references to the listener functions so they can be removed).
   - Calls `safeClose()`.

**Changes to make**:

```typescript
// Inside start(controller) { ... }

let controllerClosed = false;

const safeEnqueue = (chunk: Uint8Array | Buffer) => {
  if (controllerClosed) return;
  try {
    controller.enqueue(chunk);
  } catch {
    controllerClosed = true;
  }
};

const safeClose = () => {
  if (controllerClosed) return;
  controllerClosed = true;
  try {
    controller.close();
  } catch {
    // Already closed
  }
};
```

Then replace all `controller.enqueue(...)` calls with `safeEnqueue(...)` and all `controller.close()` calls with `safeClose()`.

Add the abort listener after spawning the child process:

```typescript
request.signal.addEventListener("abort", () => {
  controllerClosed = true;
  if (child.stdout) child.stdout.removeListener("data", onStdout);
  if (child.stderr) child.stderr.removeListener("data", onStderr);
  safeClose();
});
```

This requires extracting the anonymous `(data) => { ... }` handlers into named functions (`onStdout`, `onStderr`) so they can be removed.

**Note**: The `request` object must be accessible inside the `start(controller)` closure. Since `start` is called synchronously within the `new ReadableStream()` constructor and `request` is available in the outer `POST` function scope, this works via closure. However, the `ReadableStream` constructor doesn't pass `request` — we need to capture it. The current code already has `request` in scope from the POST handler parameter.

**Important**: Pass `request` into the closure. The stream is created inside the POST handler so `request` is already in scope.

### 1.2 Add safe-enqueue and abort handling in `terminal/route.ts` POST handler

**File**: `apps/web/src/app/api/(system)/terminal/route.ts`

Apply the exact same pattern as 1.1 to the POST handler (lines 100-174). The streaming code is nearly identical:

- Add `controllerClosed` flag.
- Add `safeEnqueue` / `safeClose` helpers.
- Extract stdout/stderr listeners to named functions.
- Add `request.signal.addEventListener("abort", ...)` to clean up.
- Replace all `controller.enqueue()` → `safeEnqueue()` and `controller.close()` → `safeClose()`.

### 1.3 Add safe-enqueue in `terminal/route.ts` GET handler (polling)

**File**: `apps/web/src/app/api/(system)/terminal/route.ts`

In the GET handler's polling stream (lines 45-79):

1. Add `controllerClosed` flag.
2. Wrap `controller.enqueue()` calls at lines 48, 62, 68 with try-catch or use `safeEnqueue`.
3. In the abort listener (line 75-77), also set `controllerClosed = true`.
4. In the `clearInterval` + `controller.close()` block (lines 70-71), use `safeClose()`.

```typescript
const stream = new ReadableStream({
  start(controller) {
    let controllerClosed = false;

    const safeEnqueue = (chunk: Uint8Array) => {
      if (controllerClosed) return;
      try {
        controller.enqueue(chunk);
      } catch {
        controllerClosed = true;
        clearInterval(pollInterval);
      }
    };

    const safeClose = () => {
      if (controllerClosed) return;
      controllerClosed = true;
      try {
        controller.close();
      } catch {
        // Already closed
      }
    };

    if (buffer) {
      safeEnqueue(encoder.encode(buffer));
      position = buffer.length;
    }

    if (!alive) {
      safeClose();
      return;
    }

    const pollInterval = setInterval(() => {
      if (controllerClosed) {
        clearInterval(pollInterval);
        return;
      }

      const currentBuffer = getOutputBuffer(id);
      if (currentBuffer && currentBuffer.length > position) {
        const newContent = currentBuffer.slice(position);
        position = currentBuffer.length;
        safeEnqueue(encoder.encode(newContent));
      }

      if (!isProcessAlive(id)) {
        const finalBuffer = getOutputBuffer(id);
        if (finalBuffer && finalBuffer.length > position) {
          safeEnqueue(encoder.encode(finalBuffer.slice(position)));
        }
        clearInterval(pollInterval);
        safeClose();
      }
    }, 100);

    request.signal.addEventListener("abort", () => {
      controllerClosed = true;
      clearInterval(pollInterval);
    });
  },
});
```

### 1.4 (Optional) Extract shared helper

If desired, create a small utility in `apps/web/src/lib/stream-utils.ts` that provides the `createSafeController(controller)` wrapper so both routes can reuse it. This is optional since the pattern is small, but keeps it DRY. Decision: implement inline first, refactor only if the duplication is bothersome.

---

## Phase 2: Ensure Input Works After Session Re-join

This phase ensures that when a user navigates away and back, they can both see output AND type into the terminal.

### 2.1 Verify and fix `terminalProcessId` state after reconnection

**File**: `apps/web/src/components/layout/AIRightSidebar.tsx`

In `reconnectToSession()` (line ~213), verify that:

1. `setTerminalProcessId(processId)` is called **before** the stream reading loop starts.
2. `setIsTerminalRunning(true)` is called so the UI knows the terminal is interactive.
3. After the stream ends (process exited), `setIsTerminalRunning(false)` is set.

Check the current code — based on the exploration, `reconnectToSession` does set the process ID:
- Line ~220: `setTerminalOutput("")` (resets output)
- It should also be calling `setTerminalProcessId(processId)` and `setIsTerminalRunning(true)`.

If these are missing, add them. The `handleTerminalInput` callback depends on `terminalProcessId` being non-null (line 425: `if (!terminalProcessId) return`).

### 2.2 Ensure TerminalViewer receives `onInput` after reconnection

**File**: `apps/web/src/components/layout/AIRightSidebar.tsx`

Check how `TerminalViewer` is rendered and whether `onInput={handleTerminalInput}` is always passed regardless of whether this is a fresh session or a reconnected one.

Look for conditional rendering patterns like:
```tsx
{isTerminalRunning && <TerminalViewer onInput={handleTerminalInput} ... />}
```

If `onInput` is conditionally omitted for reconnected sessions, fix it.

**File**: `apps/web/src/components/features/terminal/TerminalViewer.tsx`

Verify that `onData` from xterm.js calls `onInputRef.current?.(data)` (line 65-66) and that `onInputRef` is updated when the prop changes:

```typescript
const onInputRef = React.useRef(onInput);
React.useEffect(() => {
  onInputRef.current = onInput;
}, [onInput]);
```

This pattern should already be in place. If `onInput` is undefined during reconnection, the ref will be null and typing won't work.

### 2.3 Fix stale closure in `handleTerminalInput`

**File**: `apps/web/src/components/layout/AIRightSidebar.tsx`

The `handleTerminalInput` callback (line 423) uses `React.useCallback` with `[terminalProcessId]` as dependency. If `terminalProcessId` is set after `handleTerminalInput` is created, the callback will have a stale `null` value.

Verify the order of operations in `reconnectToSession`:
1. `setTerminalProcessId(processId)` — triggers re-render
2. `handleTerminalInput` re-created with new `terminalProcessId`
3. TerminalViewer receives updated `onInput` prop
4. `onInputRef` updated

This should work correctly with React's batching, but verify during implementation. If there's a timing issue, consider using a ref for `terminalProcessId` in `handleTerminalInput` instead:

```typescript
const terminalProcessIdRef = React.useRef(terminalProcessId);
React.useEffect(() => {
  terminalProcessIdRef.current = terminalProcessId;
}, [terminalProcessId]);

const handleTerminalInput = React.useCallback(async (data: string) => {
  const pid = terminalProcessIdRef.current;
  if (!pid) return;
  // ... fetch with pid
}, []); // No dependency on terminalProcessId — uses ref
```

This eliminates any stale closure issue and ensures the callback always has the latest process ID.

### 2.4 Verify server-side stdin is still writable for reconnected sessions

**File**: `apps/web/src/lib/agent-store.ts`

When a client disconnects and reconnects, the process is still in `activeProcesses` map. The `getProcess(id)` call in `agents/input/route.ts:16` will return the ChildProcess, and `process.stdin` should still be writable (it's a pipe, not tied to the HTTP stream).

Verify that `registerProcess` (line 27) doesn't add any listener that closes stdin when the stream controller closes. Looking at the code: `registerProcess` only adds `close` and `error` listeners that remove from `activeProcesses` — it does **not** close stdin. This should work correctly.

No code change needed here, just verification.

---

## Phase 3: Improve Robustness (Secondary)

These are lower-priority improvements that prevent edge cases.

### 3.1 Prevent double-close in `child.on("close")` after abort

**File**: `apps/web/src/app/api/(agents)/agents/route.ts`

After Phase 1, the abort handler sets `controllerClosed = true` and calls `safeClose()`. When the child process eventually exits, `child.on("close")` will also call `safeClose()`. Since `safeClose` checks the flag, this is safe — but the `safeEnqueue` in the close handler (line 198, for non-zero exit codes) will also be a no-op, which is correct behavior (the client is gone, no one to send the exit message to).

No additional code change needed — Phase 1's pattern handles this.

### 3.2 Clear polling interval on controller error in GET handler

**File**: `apps/web/src/app/api/(system)/terminal/route.ts`

In the `safeEnqueue` catch block for the polling stream, also `clearInterval(pollInterval)` to stop wasting CPU cycles when the client is gone. This is already included in the Phase 1.3 implementation above.

### 3.3 Handle edge case: process exits between status check and stream connect

**File**: `apps/web/src/components/layout/AIRightSidebar.tsx`

In `reconnectToSession`, there's a window between the status check (`/api/terminal?id=X&action=status`) and the stream connection (`/api/terminal?id=X`). If the process exits in this window, the GET handler returns the buffer and closes immediately (line 52-54 of terminal route). The client's while loop gets `done: true` on the first read after the buffer.

This is already handled correctly — the client will see the output and the stream will end. The `isTerminalRunning` will be set to false. No change needed.

---

## Files to Modify (Summary)

| File | Changes | Phase |
|------|---------|-------|
| `apps/web/src/app/api/(agents)/agents/route.ts` | Add `controllerClosed` flag, `safeEnqueue`/`safeClose` helpers, abort listener, extract named listener functions | 1.1 |
| `apps/web/src/app/api/(system)/terminal/route.ts` (POST) | Same pattern as agents route | 1.2 |
| `apps/web/src/app/api/(system)/terminal/route.ts` (GET) | Add safe-enqueue to polling loop, improve abort cleanup | 1.3 |
| `apps/web/src/components/layout/AIRightSidebar.tsx` | Verify/fix `terminalProcessId` set before stream loop; use ref for stable `handleTerminalInput`; ensure `onInput` always passed to TerminalViewer | 2.1, 2.2, 2.3 |
| `apps/web/src/components/features/terminal/TerminalViewer.tsx` | Verify `onInputRef` update pattern (likely no change needed) | 2.2 |
| `apps/web/src/lib/agent-store.ts` | No changes expected — verify only | 2.4 |

## Implementation Order

1. **Phase 1.1** → Fix agents/route.ts (critical crash fix)
2. **Phase 1.2** → Fix terminal/route.ts POST (same crash, same pattern)
3. **Phase 1.3** → Fix terminal/route.ts GET polling (crash on reconnect)
4. **Phase 2.1-2.3** → Fix client-side reconnection input wiring
5. **Phase 3** → Verify edge cases (mostly covered by Phase 1)

## Verification Approach

After implementation, the following scenarios should work:

1. Start an agent tool (e.g., Claude) → navigate away → navigate back → output visible, no server crash in logs.
2. Start an interactive terminal → navigate away → navigate back → output visible AND typing works.
3. Start a long-running agent → navigate away while it's running → no `TypeError: Invalid state` in server logs.
4. Start a terminal → navigate away → process continues running → navigate back → see accumulated output → type commands → see responses.
